\lecture{Лекция 12}{lec12}
\subtitle{Лекция 12 --- Программирование: Обработка последовательностей (однопроходные алгоритмы)}

\frame[plain]
{\titlepage}	% Титульный слайд


\begin{frame}
\frametitle{Программирование}

\begin{center}

\Huge
Последовательности
\end{center}
\end{frame}

	\begin{frame}
\frametitle{Понятие последовательности}

Последовательность чисел это набор чисел отделенных друг от друга.

Для последовательностей характерно, что в каждый момент времени нам доступен только \textbf{один} элемент последовательности. Поэтому все алгоритмы строятся с учетом однократного последовательного просмотра. 

\end{frame}

\begin{frame}[fragile]
\frametitle{Способы задания последовательности}
\framesubtitle{Количеством элементов}

\setlength{\columnsep}{1cm}
\begin{multicols}{2}
\small
Входные данные\\
В первой строке входного файла записано натуральное число N $(1 \leq N \leq 100)$ --- количество элементов последовательности.\\
В каждой из последующих N строк содержится одно целое число --- элемент последовательности
\begin{verbatim}
3
3
4
-93
\end{verbatim}

\columnbreak

\pause\lstinputlisting[style=CStyle]{prg/seq01.pas}

\end{multicols}


\end{frame}

\begin{frame}[fragile]
\frametitle{Способы задания последовательности}
\framesubtitle{Завершающим элементом}

\setlength{\columnsep}{1cm}
\begin{multicols}{2}
\small
Входные данные

Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не входит).
\begin{verbatim}
3 3 4 -93 0 3
\end{verbatim}

\columnbreak

\pause\lstinputlisting[style=CStyle]{prg/seq02.pas}

\end{multicols}


\end{frame}

\begin{frame}
\frametitle{Программирование}

\begin{center}

\Huge
Базовые алгоритмы обработки последовательностей
\end{center}
\end{frame}

\begin{frame}
\frametitle{Базовые алгоритмы обработки последовательностей}

\begin{enumerate}
	\item Сумма элементов
	\item Сумма и количество элементов по условию
	\item Среднее арифметическое
	\item Среднее арифметическое по условию
	\item Наибольший и наименьший элементы и их номера
	\item Наибольший/наименьший по условию
	\item Количество элементов равных наибольшему
	\item Поиск двух наибольших элементов (второго максимума)
	\item Поиск элемента равного заданному
	\item Поиск подпоследовательности по условию
\end{enumerate}


\end{frame}

\begin{frame}
\frametitle{Базовые алгоритмы обработки последовательностей}

Для определенности будем считать, что последовательность задана количеством элементов и это количество уже прочитано в переменную \texttt{n}.

Мы рассмотрим только сам алгоритм и его реализацию без детализации ввод вывода и источника данных (консоль, файл и пр.)

\textbf{Аккумулятор} --- переменная, которая изменяет свое значение на значение добавляемой величины. Пример: сумма, произведение.

\textbf{Счетчик} --- переменная, которая изменяет свое значение на 1 при определенном условии. Пример: подсчет количества, счетчик цикла.


\end{frame}

\begin{frame}[fragile]
\frametitle{Сумма элементов}
\framesubtitle{Описание алгоритма}
\begin{enumerate}
	\item Предусловия: аккумулятор = 0
	\item В цикле читаем элементы последовательности и добавляем их в аккумулятор.
	\item Постусловия: вывод аккумулятора на экран
\end{enumerate}


\end{frame}

\begin{frame}[fragile]
\frametitle{Сумма элементов}
\framesubtitle{Псевдокод}

\begin{algorithm}[H]
		\SetAlgoLined
		\KwData{Последовательность чисел размера $n$}
		\KwResult{Сумма элементов}
		аккумулятор=0\;
		
		\For{от 1 до $n$}{
			прочитать элемент\;
			аккумулятор=аккумулятор+элемент\;
	}
	вывод на экран\;
	
	\caption{Сумма элементов}
\end{algorithm}


\end{frame}


\begin{frame}[fragile]
\frametitle{Сумма элементов}
\framesubtitle{Программа}

\lstinputlisting[style=CStyle]{prg/seq03.pas}

\end{frame}


\begin{frame}[fragile]
\frametitle{Сумма и количество элементов по условию}
\framesubtitle{Описание алгоритма}

\begin{enumerate}
	\item Предусловия: аккумулятор = 0, счетчик = 0.
	\item В цикле читаем элементы последовательности.
	\item Для каждого элемента проверяем условие и если оно выполнено добавляем элемент в аккумулятор и увеличиваем счетчик.
	\item Постусловия: вывод аккумулятора и счетчика на экран.
\end{enumerate}

\end{frame}

\begin{frame}[fragile]
\frametitle{Сумма и количество элементов по условию}
\framesubtitle{Псевдокод}

\begin{algorithm}[H]
		\SetAlgoLined
		\KwData{Последовательность чисел размера $n$}
		\KwResult{Сумма и количество элементов по условию}
		аккумулятор=0\;
		счетчик=0\;
		
		\For{от 1 до $n$}{
			прочитать элемент\;
			
			\If{условие}{
				аккумулятор=аккумулятор+элемент\;
				счетчик=счетчик+1\;
			}
	}
	вывод на экран\;
	
	\caption{Сумма и количество элементов по условию}
\end{algorithm}


\end{frame}

\begin{frame}[fragile]
\frametitle{Сумма и количество отрицательных элементов}
\framesubtitle{Программа}
\lstinputlisting[style=CStyle]{prg/seq04.pas}
\end{frame}


\begin{frame}[fragile]
\frametitle{Среднее арифметическое}
\framesubtitle{Описание алгоритма}
\begin{enumerate}
	\item Предусловия: аккумулятор = 0
	\item В цикле читаем элементы последовательности и добавляем их в аккумулятор.
	\item Постусловия: расчет среднего арифметического и вывод на экран
\end{enumerate}


\end{frame}

\begin{frame}[fragile]
\frametitle{Среднее арифметическое}
\framesubtitle{Псевдокод}

\begin{algorithm}[H]
		\SetAlgoLined
		\KwData{Последовательность чисел размера $n$}
		\KwResult{Сумма элементов}
		аккумулятор=0\;
		
		\For{от 1 до $n$}{
			прочитать элемент\;
			аккумулятор=аккумулятор+элемент\;
	}
	среднее арифметическое=$\dfrac{аккумулятор}{количество\;элементов}$
	
	вывод на экран\;
	
	\caption{Среднее арифметическое}
\end{algorithm}


\end{frame}


\begin{frame}[fragile]
\frametitle{Среднее арифметическое}
\framesubtitle{Программа}

\lstinputlisting[style=CStyle]{prg/seq05.pas}

\end{frame}


\begin{frame}[fragile]
\frametitle{Среднее арифметическое по условию}
\framesubtitle{Описание алгоритма}
\begin{enumerate}
	\item Предусловия: аккумулятор = 0
	\item Для каждого элемента проверяем условие и если оно выполнено добавляем элемент в аккумулятор и увеличиваем счетчик.
	\item Постусловия: 
	\begin{enumerate}
		\item если элементов удовлетворяющих условию нет, то ОШИБКА
		\item иначе расчет среднего арифметического и вывод на экран
	\end{enumerate}
	
\end{enumerate}


\end{frame}

\begin{frame}[fragile]
\frametitle{Среднее арифметическое по условию}
\framesubtitle{Псевдокод}
\small
\begin{algorithm}[H]
		\SetAlgoLined
		\KwData{Последовательность чисел размера $n$}
		\KwResult{Сумма элементов}
		аккумулятор=0\;
		счетчик=0\;
		\For{от 1 до $n$}{
			прочитать элемент\;
			\If{условие}{
			аккумулятор=аккумулятор+элемент\;
			счетчик=счетчик+1\;
			}
	}
	\eIf{счетчик>0}{
	среднее арифметическое=$\dfrac{аккумулятор}{количество\;элементов}$}
	{ОШИБКА}
	
	\caption{Среднее арифметическое по условию}
\end{algorithm}


\end{frame}


\begin{frame}[fragile]
\frametitle{Среднее арифметическое нечетных элементов}
\framesubtitle{Программа}

\lstinputlisting[style=CStyle]{prg/seq06.pas}

\end{frame}


\begin{frame}[fragile]
\frametitle{Наибольший и наименьший элементы и их номера}
\framesubtitle{Описание алгоритма}
\begin{enumerate}
	\item Предусловия: инициализация наибольшего элемента начальным значением.
	\item Для каждого элемента если он больше наибольшего, то запоминаем этот элемент.
	\item Постусловия: вывод на экран
	
\end{enumerate}

Для поиска наименьшего все аналогично.

\end{frame}

\begin{frame}[fragile]
\frametitle{Наибольший и наименьший элементы и их номера}
\framesubtitle{Псевдокод}
\small
\begin{algorithm}[H]
		\SetAlgoLined
		\KwData{Последовательность чисел размера $n$}
		\KwResult{Наибольший и его номер}
		наибольший=первый элемент\;
		
		номер=1\;
		
		\For{от 2 до $n$}{
			прочитать элемент\;
			\If{элемент>наибольший}{
			наибольший=элемент\;
			номер=текущее значение счетчика цикла\;
			}
	}
	
	вывод на экран\;
	\caption{Наибольший и наименьший элементы и их номера}
\end{algorithm}


\end{frame}


\begin{frame}[fragile]
\frametitle{Наибольший элемент и его номер}
\framesubtitle{Программа}

\setlength{\columnsep}{-1cm}
\begin{multicols}{2}
\lstinputlisting[style=CStyle]{prg/seq07.pas}

\columnbreak

В чем разница между 

\begin{verbatim}
  if a > zmax then
\end{verbatim}

и
\begin{verbatim}
  if a >= zmax then
\end{verbatim}


\end{multicols}



\end{frame}


\begin{frame}[fragile]
\frametitle{Наибольший/наименьший по условию}
\framesubtitle{Анализ задачи}

Поиск наибольшего элемента, как мы видели раньше, состоит из двух этапов:
\begin{enumerate}
	\item Инициализация наибольшего элемента начальным значением.
	\item Поиск наибольшего
\end{enumerate}

 Тут возникает проблема: какое начальное значение взять? Начальным значением для наибольшего, в этом случае, должен быть первый элемент удовлетворяющий условию. 

В предыдущем примере мы брали первый элемент последовательности. Но первый не обязан удовлетворять условию. Хуже того в последовательности может не быть нужных нам элементов вообще.

\end{frame}

\begin{frame}[fragile]
\frametitle{Наибольший/наименьший по условию}
\framesubtitle{Анализ задачи}

В решении такой задачи возможны два варианта:

\begin{enumerate}
	\item Известен диапазон, в котором находятся элементы последовательности.
	\item Общий случай (произвольные элементы).
\end{enumerate}

Рассмотрим их по отдельности.
\end{frame}


\begin{frame}[fragile]
\frametitle{Наибольший по условию: Известен диапазон}
\framesubtitle{Описание алгоритма}
Пусть элементы последовательности лежат на отрезке [a;b]. 
\begin{enumerate}
	\item Предусловия: наибольший это число слева от левой границы отрезка.
	\item Если элемент удовлетворяет условию и он больше наибольшего, то запоминаем этот элемент.
	\item Постусловия: вывод на экран
	
\end{enumerate}

Для поиска наименьшего все аналогично.

\end{frame}

\begin{frame}[fragile]
\frametitle{Наибольший по условию: Известен диапазон}
\framesubtitle{Псевдокод}
\small
Пусть элементы последовательности лежат на отрезке [a;b]. 
\begin{algorithm}[H]
		\SetAlgoLined
		\KwData{Последовательность чисел размера $n$}
		\KwResult{Наибольший и по условию}
		наибольший=a-1\;
		\For{от 2 до $n$}{
			прочитать элемент\;
			\If{условие И элемент>наибольший}{
			наибольший=элемент\;
			}
	}
	
	вывод на экран\;
	\caption{Наибольший по условию: Известен диапазон}
\end{algorithm}


\end{frame}


\begin{frame}[fragile]
\frametitle{Наибольший отрицательный элемент: Известен диапазон}
\framesubtitle{Программа}
Пусть элементы последовательности лежат на отрезке [-20;1000]. 
\lstinputlisting[style=CStyle]{prg/seq081.pas}

\end{frame}

\begin{frame}[fragile]
\frametitle{Наибольший по условию: Общий случай}
\framesubtitle{Описание алгоритма}

\begin{enumerate}
	\item Найти первый элемент удовлетворяющий условию для инициализации наибольшего
	\item Если элемент удовлетворяет условию и он больше наибольшего, то запоминаем этот элемент.
	\item Постусловия: вывод на экран
	
\end{enumerate}

Для поиска наименьшего все аналогично.

\end{frame}

\begin{frame}[fragile]
\frametitle{Наибольший по условию: Общий случай}
\framesubtitle{Псевдокод}
\small
Пусть элементы последовательности лежат на отрезке [a;b]. 
\begin{algorithm}[H]
		\SetAlgoLined
		\KwData{Последовательность чисел размера $n$}
		\KwResult{Наибольший по условию}
		\For{от 1 до $n$}{
			прочитать элемент\;
			\eIf{условие выполнилось первый раз}{
			 наибольший=элемент\;
			 условие уже было\;
			}
			{
			 \If{условие И элемент>наибольший}{
			 наибольший=элемент\;
			}
			}
	}
	
	вывод на экран\;
	\caption{Наибольший по условию: Общий случай}
\end{algorithm}


\end{frame}


\begin{frame}[fragile]
\frametitle{Наибольший отрицательный элемент: Общий случай}
\framesubtitle{Программа}
\lstinputlisting[style=CStyle]{prg/seq082.pas}

\end{frame}


\begin{frame}[fragile]
\frametitle{Количество элементов равных наибольшему}
\framesubtitle{Описание алгоритма}

\begin{enumerate}
	\item Предусловия: наибольший это первый, количество равно 1.
	\item Если элемент больше наибольшего, то запоминаем этот элемент и сбрасываем количество на 1
	\item Если элемент равен наибольшему, то увеличиваем количество на 1
	\item Постусловия: вывод на экран
	
\end{enumerate}

\end{frame}

\begin{frame}[fragile]
\frametitle{Количество элементов равных наибольшему}
\framesubtitle{Псевдокод}
\small
\begin{algorithm}[H]
		\SetAlgoLined
		\KwData{Последовательность чисел размера $n$}
		\KwResult{Количество равных наибольшему}
		наибольший=первый элемент\;
		количество=1\;
		\For{от 2 до $n$}{
			прочитать элемент\;
			\eIf{элемент>наибольшего}{
			 наибольший=элемент\;
			 количество=1\;
			}
			{
			 \If{элемент = наибольший}{
			 количество=количество+1\;
			}
			}
	}
	
	вывод на экран\;
	\caption{Количество элементов равных наибольшему}
\end{algorithm}


\end{frame}


\begin{frame}[fragile]
\frametitle{Количество элементов равных наибольшему}
\framesubtitle{Программа}
\lstinputlisting[style=CStyle]{prg/seq09.pas}

\end{frame}

\begin{frame}[fragile]
\frametitle{Поиск двух наибольших элементов (второго максимума)}
\framesubtitle{Описание алгоритма}

\begin{enumerate}
	\item Предусловия: первый и второй наибольшие это максимум и минимум из первых двух элементов последовательности.
	\item Если элемент больше наибольшего, то второй это первый, а первый это элемент
	\item Если элемент не больше наибольшего, но больше второго, то второй это элемент
	\item Постусловия: вывод на экран
	
\end{enumerate}

\end{frame}

\begin{frame}[fragile]
\frametitle{Поиск двух наибольших элементов}
\framesubtitle{Псевдокод}
\small
\begin{algorithm}[H]
		\SetAlgoLined
		\KwData{Последовательность чисел размера $n$}
		\KwResult{Два максимума}
		наибольший1=максимум(первый, второй)\;
		наибольший2=минимум(первый, второй)\;
		\For{от 3 до $n$}{
			прочитать элемент\;
			\eIf{элемент>наибольшего1}{
			 наибольший2=наибольший1\;
			 наибольший1=элемент\;
			}
			{
			 \If{элемент > наибольший2}{
			 наибольший2=элемент\;
			}
			}
	}
	
	вывод на экран\;
	\caption{Поиск двух наибольших элементов}
\end{algorithm}


\end{frame}


\begin{frame}[fragile]
\frametitle{Поиск двух наибольших элементов}
\framesubtitle{Программа}
\small{
\lstinputlisting[style=CStyle]{prg/seq10.pas}
}
\end{frame}


\begin{frame}[fragile]
\frametitle{Поиск элемента равного заданному}
\framesubtitle{Описание алгоритма}

\begin{enumerate}
	\item Предусловия: признак того, что элемент найден
	\item Если элемент равен заданному, то поиск завершен иначе перейти к следующему элементу
	\item Постусловия: вывод на экран
	
\end{enumerate}

\end{frame}

\begin{frame}[fragile]
\frametitle{Поиск элемента равного заданному}
\framesubtitle{Псевдокод}
\small
\begin{algorithm}[H]
		\SetAlgoLined
		\KwData{Последовательность чисел размера $n$, число}
		\KwResult{Есть или нет равный заданному}
		нашли=ЛОЖЬ\;
		счетчик=1;
		\While{не просмотрены все элементы и заданный не найден}{
			прочитать элемент\;
			\eIf{элемент=заданному}{
			 нашли=ИСТИНА\;
			}
			{
			 перейти к следующему;
			}
			}
	
	вывод на экран\;
	\caption{Поиск элемента равного заданному}
\end{algorithm}


\end{frame}


\begin{frame}[fragile]
\frametitle{Поиск элемента равного заданному}
\framesubtitle{Программа}
\small{
\lstinputlisting[style=CStyle]{prg/seq11.pas}
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Поиск подпоследовательности по условию}
\framesubtitle{Описание алгоритма}
Подпоследовательность это группа идущих подряд элементов последовательности. Например для $[1,1,2,3,4,1,2,3]$ одна из подпоследовательностей будет $[2,3,4,1]$.
\begin{enumerate}
	\item Предусловия: инициализация максимальной и текущей длины, чтение первого элемента
	\item Если текущий элемент больше предыдущего, то увеличиваем текущую длину
	\item Иначе сравниваем текущую длину с максимальной и сбрасываем счетчик текущей длины
	\item Постусловия: вывод на экран
\end{enumerate}

\end{frame}

\begin{frame}[fragile]
\frametitle{Поиск подпоследовательности по условию}
\framesubtitle{Псевдокод}
\small
\begin{algorithm}[H]
		\SetAlgoLined
		\KwData{Последовательность чисел размера $n$}
		\KwResult{Наибольший п}
		максимальная длина=0;
		текущая длина=1;
		прочитать предыдущий\;
		\For{i:=2 to $n$}{
			прочитать текущий элемент\;
			\eIf{условие}{
			 текущая длина=текущая длина+1\;
			}
			{
			 \If{Текущая длина>максимальной}
			{
			 максимальная длина=текущая длина\;
			}
			текущая длина=1\;
			}
			предыдущий=текущий\;
		}
	
	вывод на экран\;
	\caption{Поиск подпоследовательности по условию}
\end{algorithm}


\end{frame}


\begin{frame}[fragile]
\frametitle{Поиск максимальной возрастающей подпоследовательности}
\framesubtitle{Программа}
\small{
\lstinputlisting[style=CStyle]{prg/seq12.pas}
}
\end{frame}